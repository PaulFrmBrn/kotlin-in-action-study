import java.io.BufferedReader
import java.io.FileReader
import java.util.concurrent.locks.Lock
import java.util.concurrent.locks.ReentrantReadWriteLock
import kotlin.concurrent.withLock

/**
 * @author PaulFrmBrn
 */
fun main(args: Array<String>) {
    println("inline functions")

    // each time lambda is used extra class is created
    // if lambda captures some variable, than new object is created on every invocation

    // function inlining helps avoiding these overhead

    // 1. ------------------------------------
    // and for function marked 'inline' for this Kotlin code snippet
    val lock = ReentrantReadWriteLock().readLock()
    synchronized(lock) {
        println("in lock")
    }
    // such Object code analogue will be generated by compiler
    // >>> function inlining
    lock.lock()
    try {
        println("in lock") // lambda code is inlined too.
        // NB there is no lambda in here anymore neither new object creation, so - no overhead
    } finally {
        lock.unlock()
    }
    // <<< function inlining

    // 2. ------------------------------------
    // but if variable of a function type id passed instead of lambda, than it can not be inlined
    // so for such code snippet
    val action = { println("in lock") }
    synchronized(lock,action)
    // this Object code analogue will be generated by compiler
    // >>> function inlining
    lock.lock()
    try {
        action() // function body is not inlined - just function call, because there is no lambda
    } finally {
        lock.unlock()
    }
    // <<< function inlining

    // NB General rule: lambda can be inlined if it's called directly or passed as an argument to another inline function
    // function can be partly inlined
    partlyInlined({ println("a") }, { println("b")})

    val people = listOf(Person("Alice",29), Person("Bob",31))

    // without lambdas
    val result = mutableListOf<Person>()
    for (person in people) {
        if (person.age < 30) {
            result.add(person)
        }
    }
    println(result)

    // using lambdas
    println(people.filter { it.age < 30 })
    // because filter() is marked as inline, bytecode for both filter() and lambda passed will be inlined where filter() is called
    // so bytecode generated for the version with lambda and version without lambda is the same

    // but
    println(people.filter { it.age < 30 } // calling filter() results to new intermediate collection to be created
                  .map { Person::name }) // which is accessed in map() call
    // because these are function calls on regular Collection objects

    // to avoid creating intermediate collections Kotlin's Sequences or Java's Streams can be used
    // function inlining can not be implemented in these cases as every sequence non-terminal method call leads
    // to storing lambda reference into sequence object

    // inlining regular functions without lambda params is useless - JVM automatically inlines code
    // while translating bytecode into machine code if this provides benefits

    // but inlining functions with lambda arguments is beneficial - call is saved and extra class and object creation,
    // JVM can not do this optimisation automatically, and it's impossible to use features like non-local return without inlining

    // NB inlining large lambdas can lead to resulting bytecode size increasing, that's why should bw avoided

    // resource management with inline functions in Kotlin
    lock.withLock {
        println("in lock through") // executes the same logic as synchronized() -
        // lambda describes actions with resource (lock object), while withLock() deals with lock() and unlock() operations

    }

    // Kotlin's use() can be used as Java's try-with-resources replacement - deals with 'Closable' interface
    // readFirstLineFromFile()

    // withLock() and use() are inline function, so no overhead is present

}

fun readFirstLineFromFile(path: String): String {
    BufferedReader(FileReader(path)).use { return it.readLine() }
}

data class Person(val name: String, val age: Int)

inline fun partlyInlined(inlined: () -> Unit, noinline notInlined: () -> Unit) {
    inlined()
    notInlined()
}

// inlined function
inline fun <T> synchronized(lock: Lock, action: () -> T): T {
    lock.lock()
    try {
        return action()
    } finally {
        lock.unlock()
    }
}